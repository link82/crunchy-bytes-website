// ==========================================================================
// Mixins and functions
//
// Note: always put function at the beginning of the sub-section
// ==========================================================================

// Generic
// ==========================================================================

@function perc($width, $container-width) {
  @return percentage($width / $container-width);
}

@function perc-image-width($image-src, $container-width) {
  @return percentage(image-width($image-src) / $container-width);
}

@function strip-units($value) {
  @return $value / ($value * 0 + 1);
}

@function vw($width, $viewport-reference-width: $viewport-width) {
  @return (strip-units($width) / strip-units($viewport-reference-width)) * 100 + vw;
}

@function vh($height, $viewport-reference-height: $viewport-height) {
  @return (strip-units($height) / strip-units($viewport-reference-height)) * 100 + vh;
}


// Elements
// ==========================================================================

@mixin boost-performance ($translate: true) {
  backface-visibility: hidden;
  transform-style: preserve-3d;

  @if ($translate) {
      transform: translate3d(0, 0, 0);
      will-change: transform;
  }
}

@mixin ir($image-url, $context: false) {
  width: image-width($image-url);
  height: image-height($image-url);
  background: image-url($image-url) no-repeat 0 0;
  background-size: 100% auto;
}

@mixin img-responsive($display: block) {
  display: $display;
  max-width: 100%;
  height: auto;
}

@mixin neutralize-list {
  margin: 0;
  padding: 0;
  list-style-type: none;
}

@mixin scrollbar-custom {

  #{if(&, "&", "*")}::-webkit-scrollbar {
      width: 6px;
      height: 6px;
  }

  #{if(&, "&", "*")}::-webkit-scrollbar-button {
      display: none;
      width: 0;
      height: 0;
  }

  #{if(&, "&", "*")}::-webkit-scrollbar-corner {
      background-color: transparent;
  }

  #{if(&, "&", "*")}::-webkit-scrollbar-thumb {
      background-color: rgba($color-light, 0.3);
  }
}

//see https://github.com/tinganho/compass-placeholder
@mixin placeholder {

  #{if(&, "&", "*")}::-webkit-input-placeholder {
      @content;
  }

  #{if(&, "&", "*")}:-moz-placeholder {
      @content;
  }

  #{if(&, "&", "*")}::-moz-placeholder {
      @content;
  }

  #{if(&, "&", "*")}:-ms-input-placeholder {
      @content;
  }
}

@mixin triangle($color: $color-dark, $size: 5px, $direction: 'up') {
  width: 0;
  height: 0;

  @if $direction == 'up' {
      border-right: $size solid transparent;
      border-bottom: $size solid $color;
      border-left: $size solid transparent;
  }
  @if $direction == 'down' {
      border-top: $size solid $color;
      border-right: $size solid transparent;
      border-left: $size solid transparent;
  }
  @if $direction == 'right' {
      border-top: $size solid transparent;
      border-bottom: $size solid transparent;
      border-left: $size solid $color;
  }
  @if $direction == 'left' {
      border-top: $size solid transparent;
      border-right: $size solid $color;
      border-bottom: $size solid transparent;
  }
}

// Typography
//
// ==========================================================================

@function em($pixels, $context: $font-size-base) {
  @if (unitless($pixels)) {
      $pixels: $pixels * 1px;
  }

  @if (unitless($context)) {
      $context: $context * 1px;
  }
  @return #{$pixels / $context}em;
}

@function rem($pixels) {
  @if (unitless($pixels)) {
      $pixels: $pixels * 1px;
  }
  @return #{$pixels / $font-size-base}rem;
}

@mixin text-ellipsis() {
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

@mixin visually-hidden {
  position: absolute;
  overflow: hidden;
  clip: rect(0 0 0 0);
  width: 1px;
  height: 1px;
  margin: -1px;
  padding: 0;
  border: 0;
}

@mixin aria-focus {
  #{if(&, "&", "*")}:focus {
    @at-root [data-whatintent="keyboard"] & {
      @content;
    }
  }
}

@mixin pointer-hover {
  #{if(&, "&", "*")}:hover {
    @at-root :global(.no-touchevents) & {
      @content;
    }
  }
}

@mixin reset-button {
  border: none;
  margin: 0;
  padding: 0;
  width: auto;
  overflow: visible;

  background: transparent;

  /* inherit font & color from ancestor */
  color: inherit;
  font: inherit;

  /* Normalize `line-height`. Cannot be changed from `normal` in Firefox 4+. */
  line-height: normal;

  /* Corrects inability to style clickable `input` types in iOS */
  -webkit-appearance: none;

  vertical-align: middle;
}


// Breakpoint viewport sizes and media queries.
@function breakpoint-next($name, $breakpoints: $mq-breakpoints, $breakpoint-names: map-keys($breakpoints)) {
  $n: index($breakpoint-names, $name);
  @return if($n < length($breakpoint-names), nth($breakpoint-names, $n + 1), null);
}

// Minimum breakpoint width. Null for the smallest (first) breakpoint.
@function breakpoint-min($name, $breakpoints: $mq-breakpoints) {
  $min: map-get($breakpoints, $name);
  @return if($min != 0, $min, null);
}

// Maximum breakpoint width. Null for the largest (last) breakpoint.
// The maximum value is calculated as the minimum of the next one less 0.02px
// to work around the limitations of `min-` and `max-` prefixes and viewports with fractional widths.
@function breakpoint-max($name, $breakpoints: $mq-breakpoints) {
  $next: breakpoint-next($name, $breakpoints);
  @return if($next, breakpoint-min($next, $breakpoints) - .02px, null);
}

// Returns a blank string if smallest breakpoint, otherwise returns the name with a dash infront.
@function breakpoint-infix($name, $breakpoints: $mq-breakpoints) {
  @return if(breakpoint-min($name, $breakpoints) == null, "", "-#{$name}");
}


// Project specific mixins
@mixin full-border ($direction-h: 'top') {
  content: '';
  position: absolute;
  left: 0;
  width: 100vw;
  height: 1px;
  background-color: $color-border;
  @if ($direction-h == 'top') {
    top: 0;
  } @else {
    bottom: 0;
  }
}
